<?php

declare(strict_types=1);

namespace Tempest\Auth\OAuth\Testing;

use Closure;
use League\OAuth2\Client\Token\AccessToken;
use PHPUnit\Framework\Assert;
use Tempest\Auth\Authentication\Authenticatable;
use Tempest\Auth\Authentication\Authenticator;
use Tempest\Auth\Exceptions\OAuthStateWasInvalid;
use Tempest\Auth\OAuth\OAuthClient;
use Tempest\Auth\OAuth\OAuthConfig;
use Tempest\Auth\OAuth\OAuthUser;
use Tempest\Http\Request;
use Tempest\Http\Responses\Redirect;
use Tempest\Router\UriGenerator;
use Tempest\Support\Arr;
use Tempest\Support\Random;
use Tempest\Support\Str;

final class TestingOAuthClient implements OAuthClient
{
    private ?string $state = null;

    private(set) ?string $baseUrl = null;

    public string $clientId {
        get => $this->clientId ?? $this->config->clientId;
    }

    /**
     * The application URI to redirect to after authorization.
     */
    public string $redirectUri {
        get => $this->uri->createUri($this->redirectUri ?? $this->config->redirectTo);
    }

    /**
     * The last authorization URL that was generated by the client.
     */
    public ?string $lastAuthorizationUrl {
        get => Arr\last($this->authorizationUrls)['url'] ?? null;
    }

    /** @var array{url: string, scopes: array, options: array, state: string}[] */
    private array $authorizationUrls = [];

    /** @var array{access_token: string, token_type: 'Bearer', expires_in: int, code: string}[] */
    private array $accessTokens = [];

    /** @var array{token: AccessToken, code: string, user: OAuthUser}[] */
    private array $users = [];

    public function __construct(
        private(set) OAuthUser $user,
        private(set) readonly OAuthConfig $config,
        private readonly Authenticator $authenticator,
        private readonly UriGenerator $uri,
    ) {}

    public function buildAuthorizationUrl(array $scopes = [], array $options = []): string
    {
        $this->state = Random\secure_string(16);

        $provider = $this->config->createProvider();
        $provider->getBaseAuthorizationUrl();

        $url = sprintf(
            '%s/oauth/authorize?redirect_uri=%s&client_id=%s&state=%s',
            $this->baseUrl ?? $provider->getBaseAuthorizationUrl(),
            $this->redirectUri,
            $this->clientId,
            $this->state,
        );

        $this->authorizationUrls[] = [
            'url' => $url,
            'scopes' => $scopes,
            'options' => $options,
            'state' => $this->state,
        ];

        return $url;
    }

    public function getState(): ?string
    {
        return $this->state;
    }

    public function requestAccessToken(string $code): AccessToken
    {
        $token = new AccessToken([
            'access_token' => 'tok-' . $code,
            'token_type' => 'Bearer',
            'expires_in' => 3600,
            'code' => $code,
        ]);

        $this->accessTokens[] = [
            'code' => $code,
            'token' => $token,
        ];

        return $token;
    }

    public function fetchUser(AccessToken $token): OAuthUser
    {
        $this->users[] = [
            'token' => $token,
            'code' => Arr\get_by_key($token->getValues(), 'code'),
            'user' => $this->user,
        ];

        return $this->user;
    }

    public function createRedirect(array $scopes = [], array $options = []): Redirect
    {
        return new Redirect($this->buildAuthorizationUrl($scopes, $options));
    }

    public function authenticate(Request $request, Closure $map): Authenticatable
    {
        $expectedState = $this->state;
        $actualState = $request->get('state');

        $this->state = null;

        if ($expectedState !== $actualState) {
            throw new OAuthStateWasInvalid();
        }

        $user = $this->fetchUser($this->requestAccessToken($request->get('code')));

        $authenticatable = $map($user);

        $this->authenticator->authenticate($authenticatable);

        return $authenticatable;
    }

    /**
     * Sets the OAuth client ID.
     */
    public function withClientId(string $clientId): static
    {
        $this->clientId = $clientId;

        return $this;
    }

    /**
     * Sets the base URL for the OAuth provider.
     */
    public function withBaseUrl(string $url): static
    {
        $this->baseUrl = Str\strip_end($url, suffix: '/');

        return $this;
    }

    /**
     * Sets the redirect URI.
     */
    public function withRedirectUri(string $url): static
    {
        $this->redirectUri = $url;

        return $this;
    }

    /**
     * Replaces the user returned by the OAuth flow.
     */
    public function withUser(OAuthUser $user): static
    {
        $this->user = $user;

        return $this;
    }

    /**
     * Asserts that an authorization URL was generated with the specified scopes or options.
     */
    public function assertAuthorizationUrlGenerated(?array $scopes = null, ?array $options = null): void
    {
        Assert::assertNotEmpty($this->authorizationUrls, 'No authorization URL was generated.');

        if ($options !== null) {
            $lastUrl = Arr\last($this->authorizationUrls);

            Assert::assertEquals(
                expected: $options,
                actual: $lastUrl['options'],
                message: 'Authorization URL options do not match.',
            );
        }

        if ($scopes !== null) {
            $lastUrl = Arr\last($this->authorizationUrls);

            Assert::assertEquals(
                expected: $scopes,
                actual: $lastUrl['scopes'],
                message: 'Authorization URL scopes do not match.',
            );
        }
    }

    /**
     * Asserts that the OAuth user was fetched with the given code.
     */
    public function assertUserFetched(string $code): void
    {
        Assert::assertNotEmpty(
            actual: array_filter($this->users, fn (array $user) => $user['code'] === $code),
            message: sprintf('User with code "%s" was not handled.', $code),
        );
    }

    /**
     * Asserts that an access token was retrieved with the specified code.
     */
    public function assertAccessTokenRetrieved(?string $code = null): void
    {
        Assert::assertNotEmpty($this->accessTokens, 'No access token was retrieved.');

        if ($code !== null) {
            Assert::assertNotEmpty(
                actual: array_filter($this->accessTokens, fn (array $token) => $token['code'] === $code),
                message: sprintf('No access token was retrieved for code "%s".', $code),
            );
        }
    }

    /**
     * Asserts that the OAuth state matches the expected value.
     */
    public function assertStateEquals(string $expectedState): void
    {
        Assert::assertEquals($expectedState, $this->state, message: 'OAuth state does not match.');
    }

    /**
     * Gets the number of authorization URLs generated.
     */
    public function getAuthorizationUrlCount(): int
    {
        return count($this->authorizationUrls);
    }

    /**
     * Get the number of access tokens retrieved.
     */
    public function getAccessTokenCount(): int
    {
        return count($this->accessTokens);
    }

    /**
     * Get the number of callbacks handled.
     */
    public function getCallbackCount(): int
    {
        return count($this->users);
    }
}
